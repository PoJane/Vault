/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => KeyValueListPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian5 = require("obsidian");

// src/key-value-list.ts
var import_state = require("@codemirror/state");
var import_obsidian2 = require("obsidian");
var import_view2 = require("@codemirror/view");
var import_obsidian3 = require("obsidian");

// src/widgets.ts
var import_view = require("@codemirror/view");
var import_obsidian = require("obsidian");
var KeyValueLineWidget = class extends import_view.WidgetType {
  constructor(plugin, listId, listIndex, textLine, maxKeyWidth, listItemWidth, path) {
    super();
    this.plugin = plugin;
    this.listId = listId;
    this.listIndex = listIndex;
    this.textLine = textLine;
    this.maxKeyWidth = maxKeyWidth;
    this.listItemWidth = listItemWidth;
    this.path = path;
  }
  eq(other) {
    return this.listId === other.listId && this.listIndex === other.listIndex && this.textLine === other.textLine && this.maxKeyWidth === other.maxKeyWidth && this.listItemWidth === other.listItemWidth && this.path === other.path;
  }
  toDOM() {
    const settings = this.plugin.settings;
    const isEven = this.listIndex % 2 == 0;
    const pieces = this.plugin.parser.getPiecesFromString(
      this.textLine
    );
    const row = document.createElement("span");
    row.id = `kvl-${this.listId}-${this.listIndex}`;
    row.className = `kvl-row kvl-row-${this.listId} ${isEven ? "kvl-row-even" : "kvl-row-odd"} ${settings.stripedBackgroundType === "default" ? "striped" : ""}`;
    if (isEven && settings.stripedBackgroundType === "custom") {
      row.style.backgroundColor = settings.stripedBackgroundColor;
    }
    row.style.padding = `${settings.verticalPadding}px ${settings.horizontalPadding}px`;
    if (this.listItemWidth.row) {
      row.style.minWidth = `${this.listItemWidth.row}px`;
    }
    const rowInner = document.createElement("span");
    rowInner.className = `kvl-row-inner kvl-row-inner-${this.listId}`;
    const keySpan = document.createElement(
      settings.boldKey ? "strong" : "span"
    );
    keySpan.className = `kvl-key kvl-key-${this.listId}`;
    if (this.listItemWidth.key) {
      keySpan.style.minWidth = `${this.listItemWidth.key}px`;
    }
    const keySpanInner = document.createElement("span");
    if (this.maxKeyWidth > 0) {
      keySpanInner.style.maxWidth = `${this.maxKeyWidth}px`;
    }
    if (settings.isKeyColored) {
      keySpanInner.style.color = settings.keyColor;
    }
    keySpanInner.className = `kvl-key-inner kvl-key-inner-${this.listId}`;
    this.renderMarkdown(pieces.key, keySpanInner);
    const valueSpan = document.createElement("span");
    valueSpan.className = "kvl-value";
    if (settings.isValueColored) {
      valueSpan.style.color = settings.valueColor;
    }
    this.renderMarkdown(pieces.value, valueSpan);
    row.appendChild(rowInner);
    rowInner.appendChild(keySpan);
    keySpan.appendChild(keySpanInner);
    rowInner.appendChild(valueSpan);
    return row;
  }
  renderMarkdown(html, container) {
    import_obsidian.MarkdownRenderer.render(
      this.plugin.app,
      html,
      container,
      this.path,
      this.plugin
    );
  }
  ignoreEvent() {
    return false;
  }
};

// src/key-value-list.ts
var excludeFileFromCssClasses = (plugin) => {
  const noteFile = plugin.app.workspace.getActiveFile();
  if (noteFile) {
    const metadata = plugin.app.metadataCache.getFileCache(noteFile);
    if (metadata == null ? void 0 : metadata.frontmatter) {
      return (metadata.frontmatter.cssclasses || []).includes("nokeyvalue");
    }
  }
  return false;
};
var KeyValueList = class {
  constructor(plugin, parser) {
    this.plugin = plugin;
    this.parser = parser;
  }
  async load() {
    const plugin = this.plugin;
    const parser = this.parser;
    this.plugin.registerMarkdownPostProcessor((element, context) => {
      if (!this.plugin.settings.activeInReadMode || excludeFileFromCssClasses(plugin)) {
        return;
      }
      for (const listElement of element.findAll("ul")) {
        const listItems = listElement.findAll("li");
        const isKeyValueList = listItems.every(
          (listItem) => parser.isKeyValueLiElem(listItem.innerText.trim())
        );
        if (isKeyValueList) {
          const table = document.createElement("table");
          table.classList.add("kvl-table");
          listElement.replaceWith(table);
          let rowIndex = 0;
          for (const listItem of listItems) {
            const tr = document.createElement("tr");
            if (++rowIndex % 2 == 0) {
              if (plugin.settings.stripedBackgroundType === "custom" && plugin.settings.stripedBackgroundColor) {
                tr.style.backgroundColor = plugin.settings.stripedBackgroundColor;
              }
              tr.classList.add("kvl-row-even");
            } else {
              tr.classList.add("kvl-row-odd");
            }
            table.appendChild(tr);
            const tdKey = document.createElement("td");
            tr.appendChild(tdKey);
            const pieces = parser.getPiecesFromLiElem(listItem);
            const keyElemType = plugin.settings.boldKey ? "strong" : "span";
            const keyElem = document.createElement(keyElemType);
            keyElem.innerHTML = pieces.key;
            if (plugin.settings.isKeyColored) {
              keyElem.style.color = plugin.settings.keyColor;
            }
            tdKey.style.padding = `${plugin.settings.verticalPadding + 2}px ${plugin.settings.horizontalPadding}px`;
            tdKey.appendChild(keyElem);
            const tdValue = document.createElement("td");
            tdValue.innerHTML = pieces.value;
            tdValue.style.padding = `${plugin.settings.verticalPadding + 2}px ${plugin.settings.horizontalPadding}px`;
            if (plugin.settings.isValueColored) {
              tdValue.style.color = plugin.settings.valueColor;
            }
            tr.appendChild(tdValue);
          }
        }
      }
    });
    let isPointerDown = false;
    this.plugin.registerDomEvent(window, "pointerdown", () => {
      isPointerDown = true;
    });
    this.plugin.registerDomEvent(window, "pointerup", () => {
      isPointerDown = false;
    });
    this.plugin.registerEditorExtension(
      import_view2.ViewPlugin.fromClass(
        class KVLPlugin {
          constructor(view) {
            this.setupEditor = () => {
              const field = this.view.state.field(import_obsidian3.editorInfoField);
              let editor;
              try {
                editor = field.editor;
              } catch (error) {
                editor = void 0;
              }
              if (!editor) {
                setTimeout(this.setupEditor, 0);
                return;
              }
              this.editor = editor;
              this.updateCounter = 10;
            };
            this.view = view;
            this.listWidths = [];
            this.lastTouchedListIndex = -1;
            this.updateCounter = 0;
            this.decorations = this.buildDecorations(view, []);
            this.setupEditor();
          }
          update(update) {
            if (isPointerDown)
              return;
            if (!this.editor || !plugin.settings.activeInEditMode || excludeFileFromCssClasses(plugin)) {
              this.decorations = import_view2.Decoration.none;
              return;
            }
            const lists = this.view.viewportLineBlocks.length > 0 && this.view.visibleRanges.length > 0 ? parser.collectLists(
              this.editor,
              this.editor.offsetToPos(this.view.viewport.from).line,
              this.editor.offsetToPos(this.view.viewport.to).line
            ).filter((list) => list.isKeyValueList) : [];
            if (lists.length != this.listWidths.length) {
              this.listWidths = lists.map(() => ({
                key: 0,
                row: 0,
                keyNeedsUpdate: true,
                rowNeedsUpdate: true
              }));
            }
            const touchedListIndex = lists.findIndex(
              (list) => list.hasCursorInside
            );
            const isAnyListTouched = touchedListIndex >= 0;
            if (!isAnyListTouched && this.lastTouchedListIndex !== -1) {
              if (this.listWidths[this.lastTouchedListIndex]) {
                this.listWidths[this.lastTouchedListIndex].keyNeedsUpdate = true;
                this.listWidths[this.lastTouchedListIndex].rowNeedsUpdate = false;
              }
              this.lastTouchedListIndex = -1;
              this.updateCounter = 3;
            } else if (isAnyListTouched) {
              this.lastTouchedListIndex = touchedListIndex;
            }
            if (update.docChanged || update.viewportChanged || isAnyListTouched || this.updateCounter || parser.needsUpdate) {
              if (this.updateCounter > 0) {
                this.updateCounter--;
              }
              if (parser.needsUpdate) {
                parser.needsUpdate = false;
              }
              this.decorations = this.buildDecorations(update.view, lists);
            }
          }
          getListWidths(lists) {
            lists.forEach((_list, index) => {
              this.listWidths[index] = {
                key: Math.max(
                  this.listWidths[index].keyNeedsUpdate ? 0 : this.listWidths[index].key,
                  ...Array.from(
                    document.getElementsByClassName(`kvl-key-inner-${index}`)
                  ).map((elem) => elem.clientWidth + 20)
                ),
                row: Math.max(
                  this.listWidths[index].rowNeedsUpdate ? 0 : this.listWidths[index].row,
                  ...Array.from(
                    document.getElementsByClassName(`kvl-row-inner-${index}`)
                  ).map(
                    (elem) => elem.children[0].clientWidth + elem.children[1].clientWidth + plugin.settings.horizontalPadding * 2 + (elem.querySelector("a") ? 16 : 0)
                  )
                ),
                keyNeedsUpdate: false,
                rowNeedsUpdate: this.listWidths[index].keyNeedsUpdate
              };
            });
          }
          buildDecorations(view, lists) {
            const builder = new import_state.RangeSetBuilder();
            if (!this.editor || excludeFileFromCssClasses(plugin)) {
              return builder.finish();
            }
            const cursor = this.editor.getCursor();
            this.getListWidths(lists);
            const maxKeyWidth = plugin.settings.maxKeyWidth / 100 * view.dom.clientWidth;
            const markdownView = plugin.app.workspace.getActiveViewOfType(import_obsidian2.MarkdownView);
            lists.forEach((list, index) => {
              var _a;
              for (let lineNumber = list.start.line; lineNumber < list.end.line; lineNumber++) {
                if (lineNumber === cursor.line) {
                  continue;
                }
                const line = view.state.doc.line(lineNumber + 1);
                builder.add(
                  line.from,
                  line.to,
                  import_view2.Decoration.replace({
                    widget: new KeyValueLineWidget(
                      plugin,
                      index,
                      lineNumber,
                      line.text,
                      maxKeyWidth,
                      this.listWidths[index],
                      ((_a = markdownView == null ? void 0 : markdownView.file) == null ? void 0 : _a.path) || ""
                    )
                  })
                );
              }
            });
            return builder.finish();
          }
        },
        {
          decorations: (value) => plugin.settings.activeInEditMode && !excludeFileFromCssClasses(plugin) ? value.decorations : import_view2.Decoration.none
        }
      )
    );
  }
  async unload() {
  }
};

// src/settings.ts
var import_obsidian4 = require("obsidian");
var DEFAULT_SETTINGS = {
  activeInEditMode: true,
  activeInReadMode: true,
  displayBullet: false,
  displayBulletChar: "-",
  delimiter: ":",
  displayDelimiter: true,
  maxKeyWidth: 50,
  verticalPadding: 3,
  horizontalPadding: 12,
  boldKey: true,
  stripedBackgroundType: "default",
  stripedBackgroundColor: "",
  isKeyColored: false,
  keyColor: "",
  isValueColored: false,
  valueColor: ""
};
var SettingTab = class extends import_obsidian4.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    const foldablePadding = 42;
    new import_obsidian4.Setting(containerEl).setName("Active in edit mode").setDesc("If the plugin should be active in edit mode").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.activeInEditMode).onChange(async (value) => {
        this.plugin.settings.activeInEditMode = value;
        await this.plugin.saveData(this.plugin.settings);
        this.plugin.refresh();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Active in read mode").setDesc("If the plugin should be active in read mode").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.activeInReadMode).onChange(async (value) => {
        this.plugin.settings.activeInReadMode = value;
        await this.plugin.saveData(this.plugin.settings);
        this.plugin.refresh();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Display bullet").setDesc("If the bullet should be displayed or not").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.displayBullet).onChange(async (value) => {
        displayBulletChar.settingEl.toggleClass("disabled", !value);
        displayBulletChar.settingEl.style.height = value ? `${displayBulletChar.settingEl.innerHeight + foldablePadding}px` : "0px";
        this.plugin.settings.displayBullet = value;
        await this.plugin.saveData(this.plugin.settings);
        this.plugin.refresh();
      })
    );
    const displayBulletChar = new import_obsidian4.Setting(containerEl).setName("Bullet character").setDesc(
      "The character(s) to be displayed for bullets. The trigger bullet will always be a dash (-) regardless of this setting."
    ).setClass("foldable-setting").setClass(this.plugin.settings.displayBullet ? "enabled" : "disabled").addText(
      (text) => text.setPlaceholder(DEFAULT_SETTINGS.displayBulletChar).setValue(this.plugin.settings.displayBulletChar).onChange(async (value) => {
        this.plugin.settings.displayBulletChar = value;
        await this.plugin.saveSettings();
        this.plugin.refresh();
      })
    ).then((setting) => {
      setting.settingEl.style.height = this.plugin.settings.displayBullet ? `${setting.settingEl.clientHeight}px` : "0px";
    });
    new import_obsidian4.Setting(containerEl).setName("Display delimiter").setDesc("If the delimiter should be displayed in the key or not").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.displayDelimiter).onChange(async (value) => {
        displayDelimiterChar.settingEl.toggleClass("disabled", !value);
        displayDelimiterChar.settingEl.style.height = value ? `${displayDelimiterChar.settingEl.innerHeight + foldablePadding}px` : "0px";
        this.plugin.settings.displayDelimiter = value;
        await this.plugin.saveData(this.plugin.settings);
        this.plugin.refresh();
      })
    );
    const displayDelimiterChar = new import_obsidian4.Setting(containerEl).setName("Delimiter").setDesc(
      "The character(s) that separate the key from the value. It is possible to use several different delimiters, by separating them with commas"
    ).setClass("foldable-setting").setClass(this.plugin.settings.displayDelimiter ? "enabled" : "disabled").addText(
      (text) => text.setPlaceholder(DEFAULT_SETTINGS.delimiter).setValue(this.plugin.settings.delimiter).onChange(async (value) => {
        this.plugin.settings.delimiter = value;
        await this.plugin.saveSettings();
        this.plugin.refresh();
      })
    ).then((setting) => {
      setting.settingEl.style.height = this.plugin.settings.displayDelimiter ? `${setting.settingEl.clientHeight}px` : "0px";
    });
    new import_obsidian4.Setting(containerEl).setName("Max key width").setDesc(
      "Maximum width of the key in percent of the editor width. 0 = no limit"
    ).addSlider(
      (slider) => slider.setLimits(0, 99, 1).setValue(this.plugin.settings.maxKeyWidth).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.maxKeyWidth = value;
        await this.plugin.saveData(this.plugin.settings);
        this.plugin.refresh();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Vertical padding").setDesc("Vertical padding of the key-value list rows (in pixels)").addText(
      (text) => {
        var _a;
        return text.setPlaceholder(DEFAULT_SETTINGS.verticalPadding.toString()).setValue((_a = this.plugin.settings.verticalPadding) == null ? void 0 : _a.toString()).onChange(async (value) => {
          let numericValue = parseInt(value);
          if (isNaN(numericValue)) {
            numericValue = 0;
          }
          this.plugin.settings.verticalPadding = numericValue;
          text.setValue(numericValue.toString());
          await this.plugin.saveSettings();
          this.plugin.refresh();
        });
      }
    );
    new import_obsidian4.Setting(containerEl).setName("Horizontal padding").setDesc("Horizontal padding of the key-value list rows (in pixels)").addText(
      (text) => {
        var _a;
        return text.setPlaceholder(DEFAULT_SETTINGS.horizontalPadding.toString()).setValue((_a = this.plugin.settings.horizontalPadding) == null ? void 0 : _a.toString()).onChange(async (value) => {
          let numericValue = parseInt(value);
          if (isNaN(numericValue)) {
            numericValue = 0;
          }
          this.plugin.settings.horizontalPadding = numericValue;
          text.setValue(numericValue.toString());
          await this.plugin.saveSettings();
          this.plugin.refresh();
        });
      }
    );
    new import_obsidian4.Setting(containerEl).setName("Bold keys").setDesc("It the keys should be rendered in a bold font").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.boldKey).onChange(async (value) => {
        this.plugin.settings.boldKey = value;
        await this.plugin.saveData(this.plugin.settings);
        this.plugin.refresh();
      })
    );
    const backgroundColorOptions = [
      { key: "none", label: "No background color" },
      { key: "default", label: "Default background color (based on theme)" },
      { key: "custom", label: "Custom background color" }
    ];
    new import_obsidian4.Setting(containerEl).setName("Striped background").setDesc("Choose if even rows should have another background color").addDropdown((dropdown) => {
      backgroundColorOptions.forEach((option) => {
        dropdown.addOption(option.key, option.label);
      });
      dropdown.setValue(this.plugin.settings.stripedBackgroundType);
      dropdown.onChange(async (value) => {
        this.plugin.settings.stripedBackgroundType = value;
        await this.plugin.saveData(this.plugin.settings);
        this.display();
        this.plugin.refresh();
      });
    });
    if (this.plugin.settings.stripedBackgroundType === "custom") {
      new import_obsidian4.Setting(containerEl).setName("Striped background color").setDesc("Choose the color of the striped background.").addColorPicker(
        (color) => color.setValue(this.plugin.settings.stripedBackgroundColor).onChange(async (value) => {
          this.plugin.settings.stripedBackgroundColor = value;
          await this.plugin.saveData(this.plugin.settings);
          this.plugin.refresh();
        })
      );
    }
    new import_obsidian4.Setting(containerEl).setName("Custom key color").setDesc("If a custom color should be used for the keys").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.isKeyColored).onChange(async (value) => {
        this.plugin.settings.isKeyColored = value;
        await this.plugin.saveData(this.plugin.settings);
        this.display();
        this.plugin.refresh();
      })
    );
    if (this.plugin.settings.isKeyColored) {
      new import_obsidian4.Setting(containerEl).setName("Key color").setDesc("Choose the color of the keys.").addColorPicker(
        (color) => color.setValue(this.plugin.settings.keyColor).onChange(async (value) => {
          this.plugin.settings.keyColor = value;
          await this.plugin.saveData(this.plugin.settings);
          this.plugin.refresh();
        })
      );
    }
    new import_obsidian4.Setting(containerEl).setName("Custom value color").setDesc("If a custom color should be used for the values").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.isValueColored).onChange(async (value) => {
        this.plugin.settings.isValueColored = value;
        await this.plugin.saveData(this.plugin.settings);
        this.display();
        this.plugin.refresh();
      })
    );
    if (this.plugin.settings.isValueColored) {
      new import_obsidian4.Setting(containerEl).setName("Value color").setDesc("Choose the color of the values.").addColorPicker(
        (color) => color.setValue(this.plugin.settings.valueColor).onChange(async (value) => {
          this.plugin.settings.valueColor = value;
          await this.plugin.saveData(this.plugin.settings);
          this.plugin.refresh();
        })
      );
    }
    new import_obsidian4.Setting(containerEl).setName("Reset settings").setDesc("Reset all settings to their default values").addButton(
      (button) => button.setButtonText("Reset settings").onClick(async () => {
        if (confirm("Are you sure you want to reset the settings?")) {
          this.plugin.settings = Object.assign({}, DEFAULT_SETTINGS);
          await this.plugin.saveData(this.plugin.settings);
          this.display();
          this.plugin.refresh();
        }
      })
    );
  }
};

// src/list.ts
var List = class {
  constructor(start, end, isKeyValueList, hasCursorInside) {
    this.start = start;
    this.end = end;
    this.isKeyValueList = isKeyValueList;
    this.hasCursorInside = hasCursorInside;
  }
};

// src/utils.ts
function escapeRegExp(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function removeInvalidHtmlTags(inputString) {
  const tagRegex = /<\/?([a-z][a-z0-9]*)\b[^>]*>/gi;
  let match;
  const stack = [];
  const invalidTags = [];
  while ((match = tagRegex.exec(inputString)) !== null) {
    const fullTag = match[0];
    const tagName = match[1];
    const isClosingTag = fullTag[1] === "/";
    if (isClosingTag) {
      if (stack.length === 0 || stack[stack.length - 1].tagName !== tagName) {
        invalidTags.push(fullTag);
      } else {
        stack.pop();
      }
    } else {
      stack.push({ tagName, fullTag });
    }
  }
  stack.forEach((tag) => invalidTags.push(tag.fullTag));
  let resultString = inputString;
  invalidTags.forEach((tag) => {
    resultString = resultString.replace(tag, "");
  });
  return resultString;
}

// src/list-parser.ts
var listItemReg = new RegExp(`^[ 	]*-(.*)`);
var ListParser = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.needsUpdate = false;
    this.update();
  }
  update() {
    const bullet = "-";
    const delimiter = escapeRegExp(
      this.plugin.settings.delimiter || DEFAULT_SETTINGS.delimiter
    );
    const delimiters = delimiter.split(",").map((d) => d.trim()).join("|");
    this.keyValueReg = new RegExp(
      `^[ 	]*${bullet}(.*[^:])(${delimiters}) (.*)`
    );
    this.liElemReg = new RegExp(`^(.*[^:])(${delimiters}) (.*)$`);
    this.needsUpdate = true;
  }
  /**
   * Collects all lists within a given range.
   * @param  {Editor} editor    The editor to parse.
   * @param  {Number} startLine The line to start parsing from.
   * @param  {Number} endLine   The line to stop parsing at.
   * @return {List[]}           A list of all lists found.
   * @public
   */
  collectLists(editor, startLine = 0, endLine = editor.lastLine()) {
    const lists = [];
    const cursorLine = editor.getCursor().line;
    for (let currentLine = startLine; currentLine <= endLine; currentLine++) {
      const line = editor.getLine(currentLine);
      if (this.isLineList(line)) {
        let isKeyValueList = true;
        let hasCursorInside = false;
        let listEndLineLookup = currentLine;
        while (listEndLineLookup <= editor.lastLine()) {
          const line2 = editor.getLine(listEndLineLookup);
          if (!this.isLineList(line2)) {
            break;
          }
          if (cursorLine === listEndLineLookup) {
            hasCursorInside = true;
          }
          if (!this.isKeyValueListItem(line2) && cursorLine !== listEndLineLookup) {
            isKeyValueList = false;
          }
          if (listEndLineLookup >= endLine) {
            listEndLineLookup = endLine;
            break;
          }
          listEndLineLookup++;
        }
        lists.push(
          new List(
            { line: currentLine, ch: 0 },
            {
              line: listEndLineLookup,
              ch: editor.getLine(listEndLineLookup).length
            },
            isKeyValueList,
            hasCursorInside
          )
        );
        currentLine = listEndLineLookup;
      }
    }
    return lists;
  }
  isLineList(line) {
    return listItemReg.test(line);
  }
  isKeyValueLiElem(line) {
    return this.liElemReg.test(line.replace("<br>", "\n"));
  }
  getPiecesFromLiElem(listItem) {
    const match = listItem.innerHTML.replace("\n", " ").trim().replace("&gt;", ">").replace("&lt;", "<").match(this.liElemReg);
    let key = (match == null ? void 0 : match[1]) || "";
    if (this.plugin.settings.displayBullet) {
      key = `${this.plugin.settings.displayBulletChar} ${key}`;
    }
    const delimiter = ((match == null ? void 0 : match[2]) || "").replace(">", "&gt;").replace("<", "&lt;");
    if (this.plugin.settings.displayDelimiter) {
      key = `${key}${delimiter}`;
    }
    return {
      key: removeInvalidHtmlTags(key),
      delimiter,
      value: removeInvalidHtmlTags((match == null ? void 0 : match[3]) || "")
    };
  }
  getPiecesFromString(line) {
    const match = line.replace("&gt;", ">").replace("&lt;", "<").match(this.liElemReg);
    let key = ((match == null ? void 0 : match[1]) || "").substring(2);
    if (this.plugin.settings.displayBullet) {
      key = `\\${this.plugin.settings.displayBulletChar} ${key}`;
    }
    if (!this.plugin.settings.displayBullet && key.charAt(0) === "[") {
      key = `- ${key}`;
    } else if (this.plugin.settings.displayBullet && key.startsWith("\\- [")) {
      key = key.substring(1);
    }
    const delimiter = ((match == null ? void 0 : match[2]) || "").replace(">", "&gt;").replace("<", "&lt;");
    if (this.plugin.settings.displayDelimiter) {
      key = `${key}${delimiter}`;
    }
    const value = ((match == null ? void 0 : match[3]) || "").replace(/\[(\^\d+)\]/g, "\\$1");
    return {
      key,
      delimiter,
      value
    };
  }
  isKeyValueListItem(line) {
    return this.keyValueReg.test(line);
  }
};

// src/main.ts
var KeyValueListPlugin = class extends import_obsidian5.Plugin {
  async onload() {
    await this.loadSettings();
    this.parser = new ListParser(this);
    new KeyValueList(this, this.parser).load();
    this.addSettingTab(new SettingTab(this.app, this));
    this.registerEvent(
      this.app.metadataCache.on("changed", () => {
        this.renderPreviewMode();
      })
    );
  }
  renderPreviewMode() {
    const view = this.app.workspace.getActiveViewOfType(import_obsidian5.MarkdownView);
    if (view) {
      view.previewMode.rerender(true);
    }
  }
  refresh() {
    this.app.workspace.updateOptions();
    this.parser.update();
    this.renderPreviewMode();
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};


/* nosourcemap */